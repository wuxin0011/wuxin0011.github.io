---
title: å‰ç¼€æ ‘+æ»‘åŠ¨çª—å£è§£å†³å­ä¸²é—®é¢˜
date: 2024-01-12 19:59:23
permalink: /LeetCode/ans/substring-with-concatenation-of-all-words/
categories: 
  - LeetCode
author: 
  name: wuxin0011
  link: https://github.com/wuxin0011
tags: 
  - å‰ç¼€æ ‘
  - æ»‘åŠ¨çª—å£
---



### é¢˜å¤–è¯

åœ¨åŠ›æ‰£ä¸Šè§£å†³é—®é¢˜æœ‰æ—¶å€™è°ƒè¯•æ˜¯å¾ˆå›°éš¾çš„ï¼Œã€ps:å› ä¸ºè¦å¼€ä¼šå‘˜ :heart:ã€‘,ä¸€èˆ¬éƒ½ä¼šåœ¨æœ¬åœ°IDEä¸­åˆ›å»ºä¸€ä¸ªJavaæ–‡ä»¶ï¼Œclass Name ï¼Œå› ä¸ºå‘½åæ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œ

æ¯”å¦‚å¤åˆ¶é“¾æ¥`https://leetcode.cn/problems/substring-with-concatenation-of-all-words/` åç¼€ä¸ºæ–‡ä»¶åï¼Œå…ˆå¤åˆ¶è¿‡æ¥ `substring-with-concatenation-of-all-words`ï¼Œ

ç„¶åä¸€é€šä¿®æ”¹æ¨ªçº¿ä¸ºä¸‹åˆ’çº¿ï¼Œå¦‚æœä¸éµå¾ªé©¼å³°å‘½åï¼Œç„¶åIDEå°±ç»™å‡ºå¾ˆçƒ¦äººçš„æ³¢æµªçº¿`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`,ç„¶åä¿®æ”¹ä¸º`SubstringWithConcatenationOfAllWords`

â€¦â€¦ â˜•

æ¯«æ— ç–‘é—®è¿™äº›æ“ä½œæ˜¯ååˆ†æµªè´¹æ—¶é—´çš„ä½†æ˜¯æœ‰ä¸å¾—ä¸åšï¼Œå¦‚æœä½ ä»¥ `A`,`B` æˆ–è€…åºå·å‘½åä¹Ÿå¯ä»¥ã€‚ä½œä¸ºä¸€ä¸ªXXXX,å¯ä»¥ç”¨ä»£ç è§£å†³çš„è¿™äº›æ“ä½œï¼Œå°±æ²¡æ¯”è¦ç”¨æ‰‹äº†ï¼

ä¸ºæ­¤æˆ‘å•ç‹¬å†™äº†ä¸€ä¸ªå·¥å…·ç±» ã€ps:æš‚æ—¶æ— æ³•è·å–æ–‡å­—è¯´æ˜ä¿¡æ¯ï¼Œå› ä¸ºæ˜¯htmlæ ¼å¼ï¼Œå¦‚æœä¸€ä¸€è§£æåˆæµªè´¹æ—¶é—´äº†æ„Ÿè§‰ä½¿ç”¨ç°æœ‰çš„åº“åˆæ²¡æœ‰å¿…è¦â˜•ã€‘



```java
package com.demo.TreeNode.Code01;


import java.io.File;
import java.io.FileOutputStream;

public class BuildLeetCodeName {

	public static void main(String[] args) {
		String url = "https://leetcode.cn/problems/substring-with-concatenation-of-all-words/";
		build(url)
	}

	public static String build(String url) {
		return build(url, true, "", "");
	}

	/**
	 * 
	 * @param url
	 * @param create
	 * @param pkgName
	 * @param rootDirName
	 * @return
	 */
	public static String build(String url, boolean create, String pkgName, String rootDirName) {
		//https://leetcode.cn/problems/print-words-vertically/description/
		url = url.replace("/description", "");
		url = url.replace("https://leetcode.cn/problems/", "");
		url = url.replace("https://leetcode.cn", "");
		StringBuilder sb = new StringBuilder();
		char[] cs = url.toCharArray();
		int n = cs.length;
		for (int i = 0; i < cs.length; i++) {
			char c = cs[i];
			if (c == '/') {
				continue;
			}
			if (i == 0) {
				c = toUpper(c);
			}
			if (c == '-' && i + 1 < n) {
				i++;
				c = toUpper(cs[i]);
			}
			sb.append(c);
		}
		String fileName = sb.toString();
		if (create) {
			createFile(fileName);
		}

		return fileName;
	}

	public static boolean isLower(char c) {
		return 'a' <= c && 'z' >= c;
	}

	public static char toUpper(char c) {
		if (!isLower(c))
			return c;
		return (char) (c - 'a' + 'A');
	}

	public static void createFile(String fileName) {
		createFile(fileName, "", "");
	}

	/**
	 * åˆ›å»ºæ–‡ä»¶
	 * 
	 * @param fileName    æ–‡ä»¶å
	 * @param packageName åŒ…å é»˜è®¤ä¼šåˆ›å»ºåœ¨æ–‡ä»¶è·¯å¾„ä¸‹
	 * @param rootName    æ ¹æ–‡ä»¶å¤¹å é»˜è®¤æ˜¯ src
	 */

	public static void createFile(String fileName, String packageName, String rootName) {
		System.out.println(fileName + " create ... ");
		String className = fileName;
		// è·å–åŒ…ç±»ä¿¡æ¯
		if (null == packageName || packageName.length() == 0) {
			Package pkg = BuildLeetCodeName.class.getPackage();
			packageName = pkg.getName();
		}
        
        if (rootName == null || rootName.length() == 0) {
			rootName = "src";
		}
		StringBuilder sb = new StringBuilder();
        sb.append(rootName);
		sb.append(File.separatorChar);
		// é€šè¿‡åŒ…ç±»æ„å»ºæ–‡ä»¶åˆ›å»ºè·¯å¾„
		for (int i = 0; i < packageName.length(); i++) {
			if (packageName.charAt(i) == '.') {
				sb.append(File.separatorChar);
			} else {
				sb.append(packageName.charAt(i));
			}
		}
		sb.append(File.separatorChar);
		String path = sb.toString();
		File file = new File(path);

		if (!file.exists()) {
			file.mkdirs();
		}

		sb.append(fileName);
		if (!fileName.endsWith(".java")) {
			sb.append(".java");
		}
		fileName = sb.toString();
		file = new File(fileName);
		if (file.exists()) {
			System.out.println("create fail ! because " + className + " already exists! on" + fileName);
			return;
		}

		try {
			file.createNewFile();
			FileOutputStream fos = new FileOutputStream(file);

			StringBuilder info = new StringBuilder();

			// å†™å…¥æ–‡ä»¶å†…å®¹
            if( packageName != null && packageName.length() != 0 ){
                info.append("package");
                info.append(" ");
                info.append(packageName);
                info.append(";");
            }
			for (int i = 0; i < 3; i++) {
				info.append("\n");
			}
			
			info.append("import java.util.*;");
			
			for (int i = 0; i < 3; i++) {
				info.append("\n");
			}

			info.append("public class "+className+" {\r\n"
					+ "	\r\n"
					+ "	\r\n"
					+ "	static class Solution {\r\n"
					+ "		\r\n"
					+ "	}\r\n"
					+ "\r\n"
					+ "	public static void main(String[] args) {\r\n"
					+ "		Solution solo = new Solution();\r\n"
					+ "	}\r\n"
					+ "\r\n"
					+ "}");

			fos.write(info.toString().getBytes());

			fos.flush();
			fos.close();
			System.out.println("create class success:" + className);
		} catch (Exception e) {
			e.printStackTrace();
		}

	}


}

```



æ§åˆ¶å°æ‰“å°æˆåŠŸä¿¡æ¯

```txt
SubstringWithConcatenationOfAllWords create ... 
create class success:SubstringWithConcatenationOfAllWords
```



ç”Ÿæˆçš„æ–‡ä»¶

```java
package com.demo.TreeNode.Code01;


import java.util.*;


public class SubstringWithConcatenationOfAllWords {
	
	
	static class Solution {
		
	}

	public static void main(String[] args) {
		Solution solo = new Solution();
	}

}
```

å¯ä»¥çœ‹åˆ°ç”Ÿæˆæ–‡ä»¶åŒ…æ‹¬ä¸€ä¸‹å†…å®¹

- package ä¸€èˆ¬ä¸ºå½“å‰è¿è¡ŒåŒ…
- è‡ªåŠ¨å¼•å…¥ `java.util.*;` è¿™ä¸ªæ˜¯å…è®¸çš„
- ç±»åç¬¦åˆé©¼å³°å‘½åè§„èŒƒã€‚
- è‡ªåŠ¨åˆ›å»º `main` å‡½æ•°å¹¶åˆ›å»ºè°ƒç”¨å¯¹è±¡`Solution`

ä½ åªéœ€è¦åœ¨ `Solution` ä¸­ç¼–å†™å‡½æ•°é€»è¾‘æˆ–è€…å¤åˆ¶è¿‡æ¥è°ƒè¯•ğŸ–

æ˜¯ä¸æ˜¯ç®€åŒ–æ“ä½œäº†å‘¢ï¼Ÿ



### é¢˜ç›®é“¾æ¥

[ä¸²è”æ‰€æœ‰å­ä¸²](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)



### æ€è·¯

åˆ†æ

1. æ ¹æ®é¢˜ç›®å¯çŸ¥`words` ä¸­å•è¯æ¯ä¸ªé•¿åº¦ç›¸ç­‰ ä»é•¿åº¦ä¿¡æ¯å¯ä»¥çŸ¥é“ è¿™ä¸ªæƒ³åˆ°æ»‘åŠ¨çª—å£
2. å•è¯æ²¡è¯´èƒ½ä¸èƒ½é‡å¤ï¼Œä»…ä»…è¯´æ¯ä¸ªå•è¯åªèƒ½ä½¿ç”¨ä¸€æ¬¡**è¿™ä¸ªå¾ˆé‡è¦** è¿™ä¸ªè”æƒ³åˆ°å‰ç¼€æ ‘
3. æ¯ä¸ªç´¢å¼•ä½ç½®å•è¯åªèƒ½å¿…é¡»ä½¿ç”¨ä¸”åªèƒ½ä½¿ç”¨ä¸€æ¬¡ 





ä¸€èˆ¬æ¥è¯´å‰ç¼€æ ‘æ„å»ºæ˜¯è¿™æ ·çš„

```java
static class TrieNode {
    TrieNode[] nexts;
    boolean isEnd; // æ˜¯å¦ä¸ºç»“æŸä½ç½®

    public TrieNode() {
        this.nexts = new TrieNode[26];
        this.isEnd = false;
    }
}


// è¾…åŠ©å‡½æ•°æ„å»ºå‰ç¼€æ ‘
public static void buildTrieNode(TrieNode root, String[] words) {
    for (String s : words) {
        TrieNode cur = root;
        for (int i = 0; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a';
            if (cur.nexts[idx] == null) {
                cur.nexts[idx] = new TrieNode();
            }
            cur = cur.nexts[idx];
        }
        cur.isEnd = true;
    }
}
```





è¿™æ ·è‚¯å®šä¸é€šè¿‡ï¼Œæ¯”å¦‚

```java
String[] words = { "ab", "ca"}; 
String s = "abab";
```

è¿™ä¸ªæµ‹è¯•æ¡ˆä¾‹åº”è¯¥æ˜¯`[]`

ä½†æ˜¯å› ä¸ºä¸çŸ¥é“æœ‰å¤šå°‘ä¸ª`ab`é€ æˆ`abab` ä¹Ÿèƒ½é€šè¿‡

ä½œä¸ºè®¡æ•°å™¨ï¼Œæ€ä¹ˆèƒ½å°‘äº† å“ˆå¸Œå‡½æ•°å‘¢ ï¼Ÿ`map.put(cur, cur.val);`

æ­¤æ—¶å‰ç¼€æ ‘æ„é€ æˆä¸‹é¢æ‰€ç¤º

```java
static class TrieNode {
    TrieNode[] nexts;
    int val; // è¡¨ç¤ºå¤šå°‘ä¸ª
    boolean isEnd; // æ˜¯å¦ä¸ºç»“æŸä½ç½®

    public TrieNode() {
        this.nexts = new TrieNode[26];
        this.isEnd = false;
        this.val = 0;
    }
}
```

æ­¤å¤–ä¸èƒ½å¯¹å‰ç¼€æ ‘åšä»»ä½•ä¿®æ”¹ã€ä¿®æ”¹åé¢å°±æ— æ³•åˆ¤æ–­äº†!ã€‘

å› æ­¤éœ€è¦ä¸¤ä¸ªå“ˆå¸Œå‡½æ•°è¾…åŠ©æ¥è®°ä½è¯¥çª—å£ä¸­å•è¯ä½¿ç”¨æ•°é‡

- ä¸€ä¸ªç”¨æ¥è®°å½•åˆå§‹çŠ¶æ€ä¿¡æ¯
- ä¸€ä¸ªç”¨æ¥å½“å‰ä½¿ç”¨ä¿¡æ¯

æ­¤æ—¶ä½¿ç”¨åˆ¤æ–­æƒ…å†µåº”è¯¥æ˜¯

- åˆæ²¡æœ‰è·¯å¾„
- è¾…åŠ©å“ˆå¸Œå‡½æ•°å’Œåˆå§‹å‡½æ•°å¤§å°æ‰€æœ‰å†…å®¹å¿…é¡»å…¨ç­‰
  - size
  - cnt

éœ€æ³¨æ„ ç”±äºmap ä¸­å­˜æ”¾valueæ˜¯intçš„åŒ…è£…ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´ åœ¨å¯¹è±¡ç›¸ç­‰èŒƒå›´ä¸º`[-128,127] `ï¼Œæ‰€ä»¥åº”è¯¥ä½¿ç”¨`equlas`æ–¹æ³•ï¼ˆps:å› ä¸ºè¿™é‡Œæˆ‘è¢«å‘äº†æäº¤äº†å¥½å‡ æ¬¡ä¸é€šè¿‡ğŸ˜…ï¼‰ï¼Œè¿™ä¹ˆç®€å•ä¸œè¥¿éƒ½èƒ½å¿˜è®°ã€‚



å› æ­¤è§£ç­”å¦‚ä¸‹

```java
package com.demo.TreeNode.Code01;

import java.util.*;

public class SubstringWithConcatenationOfAllWords {

	static class Solution {
        
		static class TrieNode {
			TrieNode[] nexts;
			int val; // è¯¥ä½ç½®ç»“æŸæœ‰å¤šå°‘ä¸ª
			boolean isEnd; // æ˜¯å¦ä¸ºç»“æŸä½ç½®

			public TrieNode() {
				this.nexts = new TrieNode[26];
				this.val = 0;
				this.isEnd = false;
			}
		}

		/**
		 * æ„å»ºå‰ç¼€æ ‘
		 * 
		 * @param root  æ ‘
		 * @param words è·¯å¾„å•è¯
		 */
		public static void buildTrieNode(TrieNode root, String[] words, Map<TrieNode, Integer> map) {
			for (String s : words) {
				TrieNode cur = root;
				for (int i = 0; i < s.length(); i++) {
					int idx = s.charAt(i) - 'a';
					if (cur.nexts[idx] == null) {
						cur.nexts[idx] = new TrieNode();
					}
					cur = cur.nexts[idx];
				}
				cur.isEnd = true;
				cur.val++;
				map.put(cur, cur.val);
			}
		}

		/**
		 * æ£€æŸ¥
		 * 
		 * @param root å‰ç¼€æ ‘
		 * @param s    å½“å‰å•è¯
		 * @param st   æ£€æŸ¥å¼€å§‹ç´¢å¼•
		 * @param ed   ç»“æŸç´¢å¼•
		 * @param step æ¯æ¬¡ç§»åŠ¨ç´¢å¼•
		 * @return boolean
		 */
		public static boolean check(TrieNode root, String s, int st, int ed, int step, Map<TrieNode, Integer> map) {
			Map<TrieNode, Integer> helpMap = new HashMap<>();
			for (int i = st; i < ed; i += step) {
				int cnt = 0;
				TrieNode cur = root;
				while (cnt != step) {
					int index = s.charAt(i + cnt) - 'a';
					if (cur.nexts[index] == null) {
						return false;
					}
					cur = cur.nexts[index];
					cnt++;
				}
				if (!cur.isEnd)
					return false;
				int val = helpMap.getOrDefault(cur, 0) + 1;
				if (val > map.get(cur))
					return false;
				helpMap.put(cur, val);
			}

			if (helpMap.size() != map.size()) {
				return false;
			}

			for (Map.Entry<TrieNode, Integer> m : map.entrySet()) {
				if (!helpMap.containsKey(m.getKey())) {
					return false;
				}

				// è‰¹ è¿™é‡Œåˆå¿˜è®°äº† Integer > 127 æ—¶å€™æ¯”è¾ƒè¦ä½¿ç”¨å¯¹è±¡æ¯”è¾ƒ
				if (!m.getValue().equals(helpMap.get(m.getKey()))) {
					return false;
				}
			}

			return true;
		}

		public List<Integer> findSubstring(String s, String[] words) {

			List<Integer> ans = new ArrayList<>();
			int n = s.length();
			int m = words.length;
			int step = words[0].length();
			int width = m * step;
			// å¦‚æœ words ä¸­æ‰€æœ‰å•è¯æ„æˆå­—ä¸²æ•°é‡è¿˜ä¸å¤Ÿ è¯´æ˜éœ€è¦é€€å‡º
			if (width > n)
				return ans;
			TrieNode root = new TrieNode();
			Map<TrieNode, Integer> map = new HashMap<>();

			// æ„å»ºå‰ç¼€æ ‘
			buildTrieNode(root, words, map);
			for (int i = 0; i < n - width + 1; i++) {
				if (check(root, s, i, i + width, step, map)) {
					ans.add(i);
				}
			}
			return ans;
		}

	}

	public static void main(String[] args) {
		Solution sub = new Solution();
		String[] words = { "foo", "bar" }; 
		String s = "barfoothefoobarman";

		System.out.println(sub.findSubstring(s, words));
		String s1 = "barfoofoobarthefoobarman";

		String[] words1 = { "bar", "foo", "the" }; 
		System.out.println(sub.findSubstring(s1, words1));

		String[] words2 = { "word", "good", "best", "good" }; 
		String s2 = "wordgoodgoodgoodbestword";

		System.out.println(sub.findSubstring(s2, words2));

	}

}
```



