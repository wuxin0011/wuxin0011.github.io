---
title: tomcat源码探究
date: 2023-08-26 12:01:23
permalink: /pages/tomcat-source-read/
categories:
  - 后端
  - Java
tags:
  - tomcat
author: 
  name: wuxin0011
  link: https://github.com/wuxin0011
---










## 前言

<p align="center"> <a href="https://tomcat.apache.org/" style="text-algin:center;"><img src="https://tomcat.apache.org/res/images/tomcat.png"/></a </p>



### 什么是web服务器？



了解web服务器需要了解一下知识

- `http `协议
- `IP `和 `域名`
- `DNS `解析
- 静态和动态内容
- 页面和文件

### tomcat发展历史

- [tomcat更新日志](https://tomcat.apache.org/whichversion.html)

### 为什么要学习 tomcat ？

`tomcat` 作为一款年代久远且经典的服务器，现在还是 `springboot` 内嵌的服务器,随着`jdk`从 `1.0` 到如今 `21.x`，`http`也从最初 `0.9`到如今`3.0`,[了解http发展历史](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP) ,为适应新新技术`tomcat`自身也需要迭代、优化，,但是不管怎么升级，核心架构是不会改变的，`tomcat`之所以经典优秀是其设计十分精妙，灵活使用设计模式，可以使得`tomcat`很容易迭代升级。所以我们要学习核心架构，学习为什么这么设计，学习tomcat是使用如何巧用`设计模式`。

### 同类型服务器



1. [Apache HTTP Server](https://tomcat.apache.org/v)：
   - 优点：成熟稳定，广泛使用；高度可配置；良好的性能和安全性。
   - 缺点：对于处理动态内容和负载均衡等高级功能，需要与其他工具结合使用。
   - 编程语言：Java 。
2. [NGINX](https://nginx.org/en/)：
   - 优点：轻量级，占用资源少；高性能和高并发处理能力；能够作为反向代理服务器和负载均衡器。
   - 缺点：不支持Java Servlet规范；对动态内容的处理相较于Apache稍差。
   - 编程语言：C。
3. [Jetty](https://eclipse.dev/jetty/download.php)：
   - 优点：轻量级、快速启动和嵌入式部署；良好的Servlet支持；可扩展性强。
   - 缺点：对于处理大型应用和高并发负载情况可能不如其他服务器。
   - 编程语言：Java。
4. [Undertow](https://undertow.io/)：
   - 优点：轻量级、快速启动；出色的性能；支持HTTP/2和WebSocket等新的Web标准。
   - 缺点：相对较新的项目，生态系统和社区相对较小。
   - 编程语言：Java。



还有其他服务器就不介绍了 可自行百度!





## 认识tomcat

### tomcat名称与Logo 

在计算机领域 `取名`和`Logo`可以说一款软件首要难题了，一个好的`Logo`和`名称` ,可以使得软件就能在初很好的宣传！

Tomcat最初是由Sun的[软件构架师](https://www.zhihu.com/search?q=软件构架师&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1319174310})詹姆斯·邓肯·[戴维森](https://www.zhihu.com/search?q=戴维森&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1319174310})开发的。后来他帮助将其变为[开源项目](https://www.zhihu.com/search?q=开源项目&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1319174310})，并由Sun贡献给Apache[软件基金会](https://www.zhihu.com/search?q=软件基金会&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1319174310})。由于大部分开源项目O'Reilly都会出一本相关的书，并且将其封面设计成某个动物的素描，因此他希望将此项目以一个动物的名字命名。因为他希望这种动物能够自己照顾自己，最终，他将其命名为Tomcat（英语公猫或其他雄性[猫科动物](https://www.zhihu.com/search?q=猫科动物&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1319174310})）。而O'Reilly出版的介绍Tomcat的书籍（ISBN 0-596-00318-8）[1]的封面也被设计成了一个[公豹](https://www.zhihu.com/search?q=公豹&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1319174310})的形象。而Tomcat的Logo兼吉祥物也被设计成了一只公猫。

汤姆猫是为人熟知的，叫的上名字的公猫，并且汤姆猫与tomcat发音相似。也同样让开发者们喜爱，叫起来有种熟悉自然的感觉。

**参考**

- [tomcat名称由来](https://www.zhihu.com/question/404124506)
- [tomcat name how to get?](https://cwiki.apache.org/confluence/display/TOMCAT/About)



###  什么是 servlet 标准 ？ 

标准也可以称之为一种协议，目的是为了增加软件的可移植性，`tomcat` 是基于[servlet api](https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/package-summary.html) 实现的，

Servlet 标准是指 Java Servlet 规范，它定义了一种用于开发基于 Java 的 Web 应用程序的标准接口和行为。Java Servlet 是在服务器上运行的小型 Java 程序，主要用于处理客户端（如浏览器）发送的 HTTP 请求并生成响应。

Servlet 标准由 Java Community Process（JCP）组织制定和管理，旨在提供一个规范化的方式来创建可移植、可扩展和安全的 Web 应用程序。Servlet 标准定义了 Servlet 接口、生命周期方法、请求处理、会话管理、线程安全等方面的规范。

通过实现 Servlet 标准接口，开发人员可以编写处理 HTTP 请求和生成 HTTP 响应的 Java 类。Servlet 在服务器中作为独立的组件运行，并由服务器容器（如 Tomcat）负责管理它们的生命周期、线程安全性等。



**优势:**

1. 可移植性：基于 Servlet 标准编写的应用程序可以在任何支持 Servlet 规范的服务器上运行，无需修改代码。

2. 可扩展性：开发人员可以使用 Servlet 标准的扩展机制来添加额外的功能，如过滤器、监听器等，以满足特定的需求。

3. 安全性：Servlet 标准提供了一些机制来保护 Web 应用程序的安全，如身份验证、授权等。

4. 高性能：Servlet 是基于线程池模型运行的，可以有效地处理多个并发请求。

5. 简单易学：相对于其他服务器端技术（如 CGI），Servlet 的编写和部署相对简单，并且与 Java 语言紧密结合。



**参考**

- [servlet jsr 标准](https://www.jcp.org/en/jsr/summary?id=servlet)

- [oracle 官方](https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html)
- [tomcat servlet api](https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/package-summary.html)
- [beginnersbook-servlet](https://beginnersbook.com/2013/05/servlet-tutorial/)
- [servlet-api 下载](http://www.java2s.com/Code/Jar/s/Downloadservletapijar.htm)



### Catalina 

`catalina` 可以说是 `tomcat` 的核心组件了！看看 作者当初为什么这么命名吧！

> ```
> I talked to the original Tomcat author, James Duncan Davidson, about the 
> name choice. He gave me a surprising answer. Here's a bit of history...
> 
> Tomcat was born in response to the need for an independant servlet 
> specification implementation. James wrote it hoping that it would 
> eventually be open sourced. He figured that since most open source 
> projects had O'reilly books about them that he should name it after an 
> animal. Essentially he was thinking of an animal that would go on the 
> cover of an O'reilly book. He came up with "Tomcat" since the animal 
> represented something that could take care of itself and fend for 
> itself. That's how he came up with the name.
> Using "Catalina" was my idea, because I
> wrote most of the original code that became it.  The reasons are mundane,
> but here they are for the record:
> 
> * Even though I don't live in Southern CA, I've always liked
>   what I've read and seen of Catalina Island.
> 
> * One of the towns on the island is Avalon, and we were (at the
>   beginning) considering using the Avalon Framework
>   (http://jakarta.apache.org/avalon/) for the internal architecture.
>   It would have been a cute tie-in, but alas it didn't happen
>   that way.
> 
> * When I'm coding, I regularly have one or more cats wandering
>   around my lap and adding to the whitespace when they don't
>   think I put enough (you don't need fingers to press the space bar :-).
> 
> Another "code name" you'll hear in the Tomcat world is Jasper -- that's
> the name of the JSP page compiler part of Tomcat.  That name was carried
> over from even before my time, but I'm sure it probabbly came from the
> alliteration (JaSPer).
> ```



参考

- [catalina tomcat history](https://raibledesigns.com/rd/entry/a_bit_of_tomcat_history)

## 源码编译环境搭建



### 依赖环境

- [jetbrins idea](https://www.jetbrains.com/zh-cn/idea/download/)

- [JDK1.8](https://www.oracle.com/java/technologies/downloads/#java8)
- [Maven3.8.3](https://github.com/apache/maven/releases)
- [tomcat9.0.x](https://github.com/apache/tomcat/tree/9.0.x )





![image-20230826145631043](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826145631043.png)





### 下载





```shell
git clone -b 9.0.x https://github.com/apache/tomcat
```

### 目录结构

![tomcat dir](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826143738374.png)





1. bin：该目录包含了启动和停止 Tomcat 服务器的可执行文件。其中，startup.bat（或 startup.sh）用于启动 Tomcat，而 shutdown.bat（或 shutdown.sh）用于停止 Tomcat。

2. conf：该目录包含了 Tomcat 的配置文件。重要的配置文件有 server.xml（Tomcat 服务器的主要配置）、web.xml（Web 应用程序的配置）和 catalina.properties（Tomcat 容器的属性配置）。

3. lib：该目录包含了 Tomcat 运行时需要的库文件，例如 JAR 文件。这些库文件包括 Tomcat 自身的库和一些第三方库，如数据库驱动程序等。

4. logs：该目录存储 Tomcat 的日志文件。包括 catalina.out（Tomcat 服务器的主要输出日志）、localhost.log（每个虚拟主机的日志）和 access_log（访问日志）等。

5. webapps：该目录用于存储 Web 应用程序的根目录。当部署一个新的 Web 应用程序时，只需要将应用程序的 WAR 文件或解压后的文件夹放入该目录，Tomcat 将自动加载并运行该应用程序。

6. work：该目录用于存储 Tomcat 运行时生成的临时工作文件。例如，Tomcat 将编译和存储 JSP 文件的 Java 源代码、编译后的字节码等。

7. temp：该目录用于存储临时文件，如上传的文件、会话数据等。这些文件在服务器重启时可能会被清除。

8. conf/Catalina：该目录包含了每个虚拟主机的独立配置文件。每个虚拟主机都有一个以主机名（或 IP 地址）命名的文件夹，其中包含了该虚拟主机的配置信息。

9. java 目录是源代码目录，所有源代码在该目录中



:ps home 目录是我自己建的 



### 编译运行

当前版本 `tomcat`是基于[ant](https://ant.apache.org/)打包的，对于主流的ide来说可能很多不支持了，因此换成[maven](https://maven.apache.org/)支持(其实是我只熟悉 maven)



#### 添加pom.xml

在当前目录中新建一个`pom.xml`文件，复制下面内容

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.apache.tomcat</groupId>
  <artifactId>tomcat</artifactId>
  <name>tomcat</name>
  <version>9.0</version>
  <description>tomcat  9.0.x</description>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.13.2</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>ant</groupId>
      <artifactId>ant</artifactId>
      <version>1.6.5</version>
    </dependency>
    <dependency>
      <groupId>org.easymock</groupId>
      <artifactId>easymock</artifactId>
      <version>4.3</version>
    </dependency>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.26</version>
    </dependency>
    <dependency>
      <groupId>biz.aQute.bnd</groupId>
      <artifactId>biz.aQute.bndlib</artifactId>
      <version>5.2.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>wsdl4j</groupId>
      <artifactId>wsdl4j</artifactId>
      <version>1.6.2</version>
    </dependency>
    <dependency>
      <groupId>javax.xml</groupId>
      <artifactId>jaxrpc</artifactId>
      <version>1.1</version>
    </dependency>
    <dependency>
      <groupId>org.eclipse.jdt</groupId>
      <artifactId>ecj</artifactId>
      <version>3.26.0</version>
    </dependency>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.28</version>
    </dependency>
  </dependencies>

  <build>
    <finalName>tomcat</finalName>
    <sourceDirectory>java</sourceDirectory>
    <resources>
      <resource>
        <directory>java</directory>
      </resource>
    </resources>
    <testResources>
      <testResource>
        <directory>test</directory>
      </testResource>
    </testResources>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.5.1</version>
        <configuration>
          <encoding>UTF-8</encoding>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <version>2.6</version>
      </plugin>
    </plugins>
  </build>
</project>
```



#### 添加Maven

`ctrl+shift+A` 输入 maven，选择`add Maven Project `





![image-20230826145125174](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826145125174.png)







![image-20230826145224376](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826145224376.png)



#### 启动



1、参数启动

你也可以使用 tomcat 自带脚本来启动，不过作为调式还是建议使用参数形式启动，使用该方式需要添加配置文件

![image-20230826145405276](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826145405276.png)



![image-20230826150716575](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826150716575.png)





![image-20230826150537220](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826150537220.png)







 参数配置如下：

```xml
-Dcatalina.home=D:\\desktop\\project\\tomcat\\home
-Dcatalina.base=D:\\desktop\\project\\tomcat\\home
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=D:\\desktop\\project\\tomcat\\home\\conf\\logging.properties
-Dfile.encoding=utf-8
```

注意: **具体路径根据参数路径请根据你的项目路径配置**

主类

```xml
org.apache.catalina.startup.Bootstrap
```









**最后就是启动了**

![tomcat run success !](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826153125812.png)





2、main 方法启动

第二种方式启动，就是直接启动 `main` 方法，同样该方法也是位于 `org.apache.catalina.startup.BootStrap#main()`,不过不建议使用这种方案，因为实际启动中

是不可能直接调用`main`方法的



![invoke bootstrap main method](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230826230628337.png)



`org.apache.catalina.startup.BootStrap#main()`

```java
  public static void main(String args[]) {

        synchronized (daemonLock) {
            if (daemon == null) {
                // Don't set daemon until init() has completed
                Bootstrap bootstrap = new Bootstrap();
                try {
                    bootstrap.init();
                } catch (Throwable t) {
                    handleThrowable(t);
                    t.printStackTrace();
                    return;
                }
                daemon = bootstrap;
            } else {
                // When running as a service the call to stop will be on a new
                // thread so make sure the correct class loader is used to
                // prevent a range of class not found exceptions.
                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
            }
        }

        try {
            /** 直接调用Bootstrap时，如果传入的args空，默认就是启动tomcat的行为*/
            String command = "start";
            if (args.length > 0) {
                command = args[args.length - 1];
            }

            if (command.equals("startd")) {
                args[args.length - 1] = "start";
                // 加载
                daemon.load(args);
                // 启动
                daemon.start();
            } else if (command.equals("stopd")) {
                args[args.length - 1] = "stop";
                
                daemon.stop();
            } else if (command.equals("start")) {
                daemon.setAwait(true);
                /**加载catalina*/
                daemon.load(args);
                daemon.start();
                if (null == daemon.getServer()) {
                    System.exit(1);
                }
            } else if (command.equals("stop")) {
                daemon.stopServer(args);
            } else if (command.equals("configtest")) {
                daemon.load(args);
                if (null == daemon.getServer()) {
                    System.exit(1);
                }
                System.exit(0);
            } else {
                log.warn("Bootstrap: command \"" + command + "\" does not exist.");
            }
        } catch (Throwable t) {
            // Unwrap the Exception for clearer error reporting
            if (t instanceof InvocationTargetException &&
                    t.getCause() != null) {
                t = t.getCause();
            }
            handleThrowable(t);
            t.printStackTrace();
            System.exit(1);
        }
    }
```









### 官网方式构建

- [tomcat build](https://tomcat.apache.org/tomcat-9.0-doc/building.html)





## 生命周期

同 Spring 框架中组件一样， tomcat 组件也有自己周期 。抽象来说，任何程序和万物都有自己的生命周期.

tomcat 的生命周期接口是 `org.apache.catalina.Lifecycle`

### Lifecycle

```java


/**
 * 组件生命周期方法的通用接口
 *  -----------------------------
 *  |                           |
 *  | init()                    |
 * NEW -»-- INITIALIZING        |
 * | |           |              |     ------------------«-----------------------
 * | |           |auto          |     |                                        |
 * | |          \|/    start() \|/   \|/     auto          auto         stop() |
 * | |      INITIALIZED --»-- STARTING_PREP --»- STARTING --»- STARTED --»---  |
 * | |         |                                                            |  |
 * | |destroy()|                                                            |  |
 * | --»-----«--    ------------------------«--------------------------------  ^
 * |     |          |                                                          |
 * |     |         \|/          auto                 auto              start() |
 * |     |     STOPPING_PREP ----»---- STOPPING ------»----- STOPPED -----»-----
 * |    \|/                               ^                     |  ^
 * |     |               stop()           |                     |  |
 * |     |       --------------------------                     |  |
 * |     |       |                                              |  |
 * |     |       |    destroy()                       destroy() |  |
 * |     |    FAILED ----»------ DESTROYING ---«-----------------  |
 * |     |                        ^     |                          |
 * |     |     destroy()          |     |auto                      |
 * |     --------»-----------------    \|/                         |
 * |                                 DESTROYED                     |
 * |                                                               |
 * |                            stop()                             |
 * ----»-----------------------------»------------------------------
 */
public interface Lifecycle {

    // 枚举的生命周期常量 以下生命周期都是见名知意 就不说了
    public static final String BEFORE_INIT_EVENT = "before_init";
    public static final String AFTER_INIT_EVENT = "after_init";
    public static final String START_EVENT = "start";
    public static final String BEFORE_START_EVENT = "before_start";
    public static final String AFTER_START_EVENT = "after_start";
    public static final String STOP_EVENT = "stop";
    public static final String BEFORE_STOP_EVENT = "before_stop";
    public static final String AFTER_STOP_EVENT = "after_stop";
    public static final String AFTER_DESTROY_EVENT = "after_destroy";
    public static final String BEFORE_DESTROY_EVENT = "before_destroy";
    public static final String PERIODIC_EVENT = "periodic";
    public static final String CONFIGURE_START_EVENT = "configure_start";
    public static final String CONFIGURE_STOP_EVENT = "configure_stop";


    /**
     * 给当前组件添加一个生命周期事件监听器（一般组件生命周期状态改变后，会触发事件的监听回调！！！）
     */
    public void addLifecycleListener(LifecycleListener listener);

    /**
     * 获取当前生命周期组件的所有监听器！
     */
    public LifecycleListener[] findLifecycleListeners();

    /**
     * 移除指定的生命周期监听器
     */
    public void removeLifecycleListener(LifecycleListener listener);


    /**
     * 组件初始化，这个时候INIT_EVENT事件会被发起，相应的listener将会被回调
     */
    public void init() throws LifecycleException;

    /**
     * 组件启动，这个时期会触发三个生命周期事件：BEFORE_START_EVENT，START_EVENT，AFTER_START_EVENT
     */
    public void start() throws LifecycleException;


    /**
     * 组件停止，这个时期会触发三个生命周期事件
     */
    public void stop() throws LifecycleException;

    /**
     * 组件销毁，这个时期会触发事件DESTROY_EVENT的发生
     */
    public void destroy() throws LifecycleException

    /**
     * 获取源组件的当前状态。
     */
    public LifecycleState getState();

    public String getStateName();
    
    public interface SingleUse {
    }
}

```



继承图



![image-20230827100840631](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827100840631.png)

下面详细看看各个组件继承具体情况吧！



#### webResourceRoot

![image-20230827101003366](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827101003366.png)









#### Container



![image-20230827101120512](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827101120512.png)

可以看到 container 接口是围绕下面的 `StandarXXX` 展开的,这些都是基础容器组件

- host -> StandarHost
- wrapper -> StandarWrapper
- context -> StandarContext
- engine -> StandarEngine







#### Executor

![image-20230827102411094](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827102411094.png)





这个生命周期的组件和tomcat线程调度有关，`org.apache.catalina.core.StandardThreadExecutor`中包括了tomcat基础线程属性，后面的线程参数都是根据这个类来调整的



StandardThreadExecutor 基本属性

```java
 protected static final StringManager sm = StringManager.getManager(StandardThreadExecutor.class);

    protected int threadPriority = Thread.NORM_PRIORITY;

    protected boolean daemon = true;

    protected String namePrefix = "tomcat-exec-";

    // 默认最大线程数
    protected int maxThreads = 200;

    protected int minSpareThreads = 25;

    protected int maxIdleTime = 60000;

    // 线程池
    protected ThreadPoolExecutor executor = null;

    protected String name;

    protected boolean prestartminSpareThreads = false;

    // 最大队列
    protected int maxQueueSize = Integer.MAX_VALUE;

    // org.apache.tomcat.util.threads.Constants
    // public static final long DEFAULT_THREAD_RENEWAL_DELAY = 1000L;
    protected long threadRenewalDelay =
        org.apache.tomcat.util.threads.Constants.DEFAULT_THREAD_RENEWAL_DELAY;

    // tomcat 任务队列
    // org.apache.tomcat.util.threads.TaskQueue
    // public class TaskQueue extends LinkedBlockingQueue<Runnable> {}
    private TaskQueue taskqueue = null;

```





`org.apache.catalina.core.StandardThreadExecutor#startInternal()`初始化任务队列

```java

    @Override
    protected void startInternal() throws LifecycleException {
        // 初始化任务队列
        // maxQueueSize = Integer.MAX_VALUE;
        taskqueue = new TaskQueue(maxQueueSize);
        // 初始化任务工厂
        TaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());
        // 初始化线程池
        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);
        // 延迟执行的时间
        executor.setThreadRenewalDelay(threadRenewalDelay);
        if (prestartminSpareThreads) {
            // 启动所有核心线程
            executor.prestartAllCoreThreads();
        }
        // 设置任务队列的线程池
        taskqueue.setParent(executor);
        // 更新状态 启动！
        setState(LifecycleState.STARTING);
    }

```



额，扯远了……，本来是说tomcat线程相关的参数



#### LifecycleBase



`org.apache.catalina.util.LifecycleBase` 是一个抽象类,封装了一条共用模板。





![image-20230827101549226](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827101549226.png)

![image-20230827101540833](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827101540833.png)



![image-20230827101614496](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827101614496.png)







#### WebResourceSet



![image-20230827102040678](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827102040678.png)







#### WebAppClassLoaderBase







![image-20230827102126055](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827102126055.png)







#### Service



![image-20230827102555423](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827102555423.png)

####  Server

![image-20230827102606099](https://cdn.staticaly.com/gh/wuxin0011/blog-resource@main/typora/image-20230827102606099.png)

### 总结 

简单了解下上面各个生命周期组件继承以及命名，多多少少能猜测出各个组件的作用（命名规范还是很重要），这么多组件或者类继承了生命周期`Lifecycle` 的重要性不言而喻。

上面简单介绍实现生命周期的类，对tomcat结构有个初步认识。





## BootStrap



// todo

// tomcat 核心启动入口





## Catalina





// todo

// 启动过程中分析 ，tomcat 解析 server.xml 配置为对象





## StringManager

// todo 

// 标准组件







## StandardServer





// todo 

// 标准组件





## filter



// todo 

// 分析实现各种filter基本原理

// 执行链执行原理







## Mapper



// todo 分析 Mapper 类解析结构







## 容器组件





### Host





### Engine





### Context





### Wrapper







## 类加载器



// todo

- 什么是双亲委派机制
- tomcat 为什么要打破双亲委派机制





## 多种部署方式

// todo 

// 分析tomcat如何支持多种部署流程





## 多版本支持



// todo  

// 分析 tomcat 如何实现支持多版本部署





## 多语言支持

// todo  

// 分析 tomcat 如何处理多语言支持



## 线程池





// todo  

// 分析 tomcat 线程池情况 

// tomcat线程池性能







## Tomcat设计模式



### tomcat 中使用到的设计模式如下：

- 单例模式
- 模板模式
- 装饰器模式
- 代理模式
- 观察模式
- 享元模式
- 工厂模式
- 策略模式
- 适配器模式
- 责任链模式
- 状态模式
- 建造者模式
- 访问者模式



// todo 

// 分析 tomcat 使用的设计模式 为什么要使用这些模式？









## tocmat优化

