---
title: TypeScript训练
date: 2023-05-05 08:56:57
permalink: /pages/a208cd/
categories:
  - 前端
  - 学习笔记
tags:
  - TypeScript
author:
  name: wuxin0011
  link: https://github.com/wuxin0011
---

# typeScript训练

## 一、简单

### 实现Pick

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
}
```

::: tip

- in
- keyof
- extends

:::

::: details 点击查看答案

```ts
type MyPick<T, K extends keyof T> = {

    [key in K]: T[key]

}
```

:::

### 实现Readonly



```ts
interface Todo {
    title: string
    description: string
}

const todo: MyReadonly<Todo> = {
    title: "Hey",
    description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```


::: tip 
- in
- keyof
- extends
:::




::: details 点击查看答案

```ts
type MyReadonly<T> = {
    readonly [key in keyof T]: T[key]
}
```

:::

### 实现元组转换对象

传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键/值都是从元组中遍历出来。

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```



::: danger 错误示例

:::

::: details
```ts
type TupleToObject<T extends any[]> = {
    [K in T[number]]: K
}
```
:::


::: tip 正确答案

:::

::: details 点击查看答案

```ts
type TupleToObject<T extends (number | symbol | string)[]> = {
    [K in T[number]]: K
}
```

:::

### 提取数组首项

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = First<arr1> // expected to be 'a'
type head2 = First<arr2> // expected to be 3
```

::: details 点击查看答案

```ts
type First<T extends any[]> = T extends [infer F, ...infer] ? F : []
```

:::

### 实现Unshitf

```ts

type Result = Unshift<[1, 2], 0> // [0, 1, 2]

```

::: details 点击查看答案

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

:::

### 实现Push

```ts

type Result = Push<[1, 2], 0> // [1,2,0]

```

::: details 点击查看答案

```ts
type Push<T extends any[], U> = [...T, U]
```

:::

### 获取元组长度

创建一个通用的`Length`，接受一个`readonly`的数组，返回这个数组的长度。

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

::: tip

- extends
- ts中获取数组获取长度的方式

:::

::: details 点击查看答案

```ts
type Length<T extends readonly any[]> = T['length']
```

:::

### 实现exclude

::: tip

- never
- extends

:::

::: details 点击查看答案

```ts
type MyExclude<T, U> = U extends T ? never : T
```

:::

### 实现 Include

::: tip

- never
- extends

:::

::: details 点击查看答案

```ts
type MyInclude<T, U> = U extends T ? T : never
```

:::

### 实现If

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C`
只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

example

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

::: tip

- boolean
- extends

:::

::: details 点击查看答案

```ts
type If<T extends boolean, U, P> = T extends true ? U : P
```

:::

### 实现concat

::: tip

数组的解构赋值

:::

::: details 点击查看答案

```ts
type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T, ...U];
```

:::

## 二、中等

### 获取函数返回类型

不使用 ReturnType 实现 TypeScript 的 `ReturnType<T>` 泛型。
example:

```ts
const fn = (v: boolean) => {
    if (v)
        return 1
    else
        return 2
}

type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
```


::: tip

ts中函数表示方式，可以使用关键词`infer`提取函数返回类型

:::




::: details 点击查看答案

```ts
type MyReturnType<T> = T extends (...args: any) => infer R ? R : never
```

:::




### 实现 omit

不使用 Omit 实现 TypeScript 的 Omit<T, K> 泛型。

Omit 会创建一个省略 K 中字段的 T 对象。

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
    completed: false,
}
```


::: tip

- keyof
- in
- extends
- never
- 判断对象是否存在与对象中，如果不存在，就添加属性

:::




::: details 点击查看答案

```ts
type MyOmit<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P]
}
```

:::


### 实现递归ReadOnly


```ts

```


## 三、困难

> TODO...

## 四、相关链接

[ts训练营](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)
