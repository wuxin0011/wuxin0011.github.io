---
title: TypeScriptè®­ç»ƒ
date: 2023-05-05 08:56:57
permalink: /pages/a208cd/
categories:
  - å‰ç«¯
  - å­¦ä¹ ç¬”è®°
tags:
  - TypeScript
author:
  name: wuxin0011
  link: https://github.com/wuxin0011
---

# typeScriptè®­ç»ƒ

## ä¸€ã€ç®€å•

### å®ç° Pick

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
}
```

::: tip

- in
- keyof
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyPick<T, K extends keyof T> = {

    [key in K]: T[key]

}
```

:::

### å®ç° Readonly



```ts
interface Todo {
    title: string
    description: string
}

const todo: MyReadonly<Todo> = {
    title: "Hey",
    description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```


::: tip 
- in
- keyof
- extends

:::




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyReadonly<T> = {
    readonly [key in keyof T]: T[key]
}
```

:::

### å®ç°å…ƒç»„è½¬æ¢å¯¹è±¡

ä¼ å…¥ä¸€ä¸ªå…ƒç»„ç±»å‹ï¼Œå°†è¿™ä¸ªå…ƒç»„ç±»å‹è½¬æ¢ä¸ºå¯¹è±¡ç±»å‹ï¼Œè¿™ä¸ªå¯¹è±¡ç±»å‹çš„é”®/å€¼éƒ½æ˜¯ä»å…ƒç»„ä¸­éå†å‡ºæ¥ã€‚

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```



::: danger é”™è¯¯ç¤ºä¾‹

:::

::: details
```ts
type TupleToObject<T extends any[]> = {
    [K in T[number]]: K
}
```
:::


::: tip æ­£ç¡®ç­”æ¡ˆ

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type TupleToObject<T extends (number | symbol | string)[]> = {
    [K in T[number]]: K
}
```

:::






### å®ç°æå–æ•°ç»„é¦–é¡¹

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = First<arr1> // expected to be 'a'
type head2 = First<arr2> // expected to be 3
```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type First<T extends any[]> = T extends [infer F, ...infer] ? F : []
```

:::

### å®ç°æå–æ•°ç»„æœ€åä¸€é¡¹

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = End<arr1> // expected to be 'c'
type head2 = End<arr2> // expected to be 1
```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type End<T extends any[]> = T extends [...infer, infer E] ? E : []
```

:::

### å®ç° Unshitf

```ts

type Result = Unshift<[1, 2], 0> // [0, 1, 2]

```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

:::

### å®ç° Push

```ts

type Result = Push<[1, 2], 0> // [1,2,0]

```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Push<T extends any[], U> = [...T, U]
```

:::

### è·å–å…ƒç»„é•¿åº¦

åˆ›å»ºä¸€ä¸ªé€šç”¨çš„`Length`ï¼Œæ¥å—ä¸€ä¸ª`readonly`çš„æ•°ç»„ï¼Œè¿”å›è¿™ä¸ªæ•°ç»„çš„é•¿åº¦ã€‚

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

::: tip

- extends
- tsä¸­è·å–æ•°ç»„è·å–é•¿åº¦çš„æ–¹å¼

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Length<T extends readonly any[]> = T['length']
```

:::

### å®ç° exclude

::: tip

- never
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyExclude<T, U> = U extends T ? never : T
```

:::

### å®ç° Include

::: tip

- never
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyInclude<T, U> = U extends T ? T : never
```

:::

### å®ç° If

å®ç°ä¸€ä¸ª `IF` ç±»å‹ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªæ¡ä»¶ç±»å‹ `C` ï¼Œä¸€ä¸ªåˆ¤æ–­ä¸ºçœŸæ—¶çš„è¿”å›ç±»å‹ `T` ï¼Œä»¥åŠä¸€ä¸ªåˆ¤æ–­ä¸ºå‡æ—¶çš„è¿”å›ç±»å‹ `F`ã€‚ `C`
åªèƒ½æ˜¯ `true` æˆ–è€… `false`ï¼Œ `T` å’Œ `F` å¯ä»¥æ˜¯ä»»æ„ç±»å‹ã€‚

example

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

::: tip

- boolean
- extends

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type If<T extends boolean, U, P> = T extends true ? U : P
```

:::

### å®ç° concat

::: tip

æ•°ç»„çš„è§£æ„èµ‹å€¼

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T, ...U];
```

:::

## äºŒã€ä¸­ç­‰

### å®ç°è·å–å‡½æ•°è¿”å›ç±»å‹

ä¸ä½¿ç”¨ ReturnType å®ç° TypeScript çš„ `ReturnType<T>` æ³›å‹ã€‚
example:

```ts
const fn = (v: boolean) => {
    if (v)
        return 1
    else
        return 2
}

type a = MyReturnType<typeof fn> // åº”æ¨å¯¼å‡º "1 | 2"
```


::: tip

tsä¸­å‡½æ•°è¡¨ç¤ºæ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨å…³é”®è¯`infer`æå–å‡½æ•°è¿”å›ç±»å‹

:::




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyReturnType<T> = T extends (...args: any) => infer R ? R : never
```

:::




### å®ç° Omit

ä¸ä½¿ç”¨ Omit å®ç° TypeScript çš„ Omit<T, K> æ³›å‹ã€‚

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
    completed: false,
}
```


::: tip

- keyof
- in
- extends
- never

:::




::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type MyOmit<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P]
}
```

:::


### å®ç°é€’å½’ ReadOnly


```ts
type X = {
    name: 'a',
    age: 12,
    b: {
        c: {
            a: 'role'
        }
    }
}

type Expected = {
    readonly x: {
        readonly a: 1
        readonly b: 'hi'
    }
    readonly y: 'hey'
}

```

::: tip

æˆ‘ä¸ªäººæ„Ÿè§‰è¿™ç§å†™æ³•ä¸å¥½ç†è§£

- keyof
- in
- extends
- never

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type DeepReadonly<T> = keyof T extends never ? T : { readonly [k in keyof T]: DeepReadonly<T[k]> };
```

:::



### å®ç°å…ƒç»„è½¬æ¢æˆè”åˆç±»å‹

```ts
type Arr = ['java', 'javascript', 'typescript', "node", "springboot"]

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'


```



::: tip

- é€’å½’
- infer

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

// è§£æ³•ä¸€ï¼Œè‡ªå·±åšçš„
type TupleToUnion<T extends any[]> = T extends [infer F, ...infer L] ? F | TupleToUnion<L> : never

// è§£æ³•äºŒ ï¼Œè¯´å®è¯ï¼Œæ ¹æœ¬çœ‹ä¸æ‡‚ï¼
// åŸç­”æ¡ˆé“¾æ¥ https://github.com/type-challenges/type-challenges/issues/284
type TupleToUnion<T extends any[]> = T[number]
```

:::



### å®ç°å¯é…ç½®å¯é€‰é“¾

```ts

declare const config: Chainable


const result = config
    .option('foo', 123)
    .option('name', 'type-challenges')
    .option('bar', { value: 'Hello World' })
    .get()

// expect the type of result to be:
type TR = typeof result;
interface Result {
    foo: number
    name: string
    bar: {
        value: string
    }
}


```



::: tip

- è€ƒè™‘å±æ€§æ˜¯å¦å­˜åœ¨ç±»å‹ä¸­
- å»ºé€ è€…æ¨¡å¼ï¼ˆoption æ–¹æ³•ç±»ä¼¼äºå»ºé€ è€…æ¨¡å¼ï¼‰
- æ–¹æ³•è¡¨è¾¾å¼
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
// ç¬¬ä¸€æ­¥å†™å‡ºæœ€ç®€å•å½¢å¼
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K, v: V) => T,
    get: () => T
};

// ç¬¬äºŒéƒ¨è€ƒè™‘ k æ˜¯å¦å­˜åœ¨ä¸ T ä¸­
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T ? never : K, v: V) => T,
    get: () => T
};

// ç¬¬ä¸‰æ­¥ å¦‚æœå°† K V å¯¹åº”å±æ€§æ·»åŠ åˆ° T ä¸­ è¿™é‡Œä½¿ç”¨ Omit<T,K>
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>>,
    get: () => T
};

// ç¬¬å››æ­¥ï¼Œä½¿ç”¨ Record åˆå¹¶å±æ€§
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>&Record<K,V>>,
    get: () => T
};

```


:::


### å®ç°å»æ‰å­—ç¬¦ä¸²ç©ºæ ¼


```ts

type trimed = TrimLeft<'  Hello World  '> // expected to be 'Hello World  
type trimed1 = TrimRright<'  Hello World  '> // expected to be 'Hello World  
type trimed2 = Trim<'  Hello World  '> // expected to be 'Hello World  



```

::: tip æŠŠå­—ç¬¦ä¸²å½“æ•°ç»„ç†è§£ï¼Œæ•°ç»„æ˜¯å¦‚ä½•æå–ï¼Œå­—ç¬¦ä¸²å°±å¦‚ä½•æå–
- é€’å½’

- infer

:::




::: details æŸ¥çœ‹ç­”æ¡ˆ

```ts
// ä¸€æ¬¡æ€§è§£å†³å§
type S = ' '
type TrimLeft<T extends string> = T extends `${S}${infer R}` ? TrimLeft<R>:T
type TrimRright<T extends string> = T extends `${infer R}${S}` ? TrimRright<R>:T
type Trim<T extends string> = T extends `${S}${infer R}${S}` ? Trim<R>:T
// çœ‹äº†ç­”æ¡ˆs = ' 'ä¸å‡†ç¡®ï¼Œä½¿ç”¨ S = ' ' | '\n' | '\t'
```

::: 





### å®ç°å­—ç¬¦ä¸²é¦–å­—æ¯å¤§å†™



```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```



::: tip `ts` ä¸­å­—ç¬¦ä¸²è½¬æ¢æˆå¤§å†™ `Uppercase`;å°å†™æ˜¯ `Lowercase`

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Capitalize<T extends string> = T extends `${infer F}${infer L}` ? `${Uppercase<F>}${L}` : T 

```

:::



æ‹“å±•

- å®ç° å…¨éƒ¨å¤§å†™
- å®ç° å…¨éƒ¨å°å†™



### å®ç°å­—ç¬¦ä¸²æ›¿æ¢

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // expected to be 'types are awesome!'
```



::: tip ä½¿ç”¨inferæå–ï¼Œéœ€è¦è€ƒè™‘ç©ºå­—ç¬¦ä¸²æƒ…å†µ

:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type Replace<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}`?  `${L}${T}${R}`: S
)
```

:::



**æ‹“å±•**

å®ç°å…¨å±€æ›¿æ¢

```ts
type replaced = ReplaceAll<'fun types fun are fun!', 'fun', 'awesome'> // expected to be 'awesome types awesome are awesome!'
```



::: tip æ ¹æ®ä¸Šé¢ä½¿ç”¨é€’å½’å°±å¯ä»¥äº†

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type ReplaceAll<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}` ? ReplaceAll<`${L}${T}${R}`, F, T> : S
)
```

:::


### å®ç°è·å–å­—ç¬¦ä¸²é•¿åº¦


::: tip  å­—ç¬¦ä¸²æ˜¯æ˜¯æ— æ³•ç›´æ¥è·å–é•¿åº¦ï¼Œè½¬æ¢æˆæ•°ç»„ï¼Œé€šè¿‡é€’å½’éå†ç„¶åè·å–
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type StrLen<T extends string, Arr extends string[] = []> = T extends `${infer F}${infer R}` ? StrLen<R, [...Arr, F]> : A['length']
```

// eg
type B = StrLen<"javascript"> // 10
:::



### å®ç°æ•°ç»„æ‰å¹³åŒ–

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]
```
::: tip é€’å½’
:::


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type Flatten<T extends any[], O extends any[] = []> =
  T extends [infer F, ...infer R] ? (
    (F extends any[] ? Flatten<[...F, ...R], O> : Flatten<R, [...O, F]>)
  ) : O
```
:::


### å®ç°å‚æ•°è¿½åŠ 



```ts
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean> 
// expected be (a: number, b: string, x: boolean) => number
```



::: tip å‡½æ•°è¡¨ç°å½¢å¼ä»¥åŠå‚æ•°å’Œè¿”å›ç±»å‹æå–

:::





::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

// ç¬¬ä¸€æ­¥å†™å‡ºå½¢å¼
type AppendArgument<Fn, A> = Fn extends (...args: any[]) => void?(...args: any[]) => void:never

// ç¬¬äºŒæ­¥ä½¿ç”¨inferæå–å‚æ•°å’Œè¿”å›ç±»å‹
type AppendArgument<Fn, A> = Fn extends (...args: infer P) => infer T ? (...args: [...P, A]) => T : never
```

:::



### å®ç°ä¸ºä¸€ä¸ªæ¥å£æ·»åŠ æ–°ç±»å‹

å®ç°ä¸€ä¸ªä¸ºæ¥å£æ·»åŠ ä¸€ä¸ªæ–°å­—æ®µçš„ç±»å‹ã€‚è¯¥ç±»å‹æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œè¿”å›å¸¦æœ‰æ–°å­—æ®µçš„æ¥å£ç±»å‹ã€‚

```ts
type Test = { id: '1' }
type Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }
```

::: tip æ„é€ ä¸€ä¸ªKï¼ŒVç»™å¯¹è±¡ï¼Œå‚è€ƒRecordå®ç°
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type AppendToObject<T, U extends keyof any, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```
:::

### å®ç°è¿ä¸¤ä¸ªå¯¹è±¡åˆå¹¶



```ts
type foo = {
  name: string;
  age: string;
}
type coo = {
  age: number;
  sex: string
}

type Result = Merge<foo,coo>; // expected to be {name: string, age: number, sex: string}
```

::: tip  å‚è€ƒä¸Šé¢ç»™å¯¹è±¡æ·»åŠ æ–°å±æ€§æ¡ˆä¾‹ï¼Œæ³¨æ„åé¢å¯¹è±¡åŒåå±æ€§å¿…é¡»è¦è¦†ç›–å‰é¢å¯¹è±¡è¿™ä¸ªè¦æ±‚
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type Merge<T, U, K extends keyof T = keyof T, J extends keyof U = keyof U> = {
  [key in J | K]: key extends J ? U[key] : (key extends K ? T[key] : never)
}
```
:::



### å®ç° Absolute

å®ç°ä¸€ä¸ªæ¥æ”¶string,numberæˆ–bigIntç±»å‹å‚æ•°çš„Absoluteç±»å‹,è¿”å›ä¸€ä¸ªæ­£æ•°å­—ç¬¦ä¸²

```ts
type Test = -100;
type Result = Absolute<Test>; // expected to be "100"
```

::: tip ç”¨å­—ç¬¦ä¸²å’Œinferå¤„ç†
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type Absolute<T extends string | number | bigint> = `${T}` extends `-${infer R}` ? R : `${T}`
```
:::


### å®ç°å­—ç¬¦ä¸²è½¬æ¢è”åˆç±»å‹

å®ç°ä¸€ä¸ªæ¥æ”¶string,numberæˆ–bigIntç±»å‹å‚æ•°çš„Absoluteç±»å‹,è¿”å›ä¸€ä¸ªæ­£æ•°å­—ç¬¦ä¸²

```ts
type Test = '123';
type Result = StringToUnion<Test>; // expected to be "1" | "2" | "3"
```

::: tip ç”¨inferé€’å½’å¤„ç†
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type StringToUnion<T extends string> = T extends `${infer F}${infer R}` ? F | StringToUnion<R> : never
```
:::



### å®ç°é©¼å³°å‘½åè½¬æ¢çŸ­æ¨ªçº¿å‘½å


```ts
type FooBarBaz = KebabCase<"FooBarBaz">;
const foobarbaz: FooBarBaz = "foo-bar-baz";

type DoNothing = KebabCase<"do-nothing">;
const doNothing: DoNothing = "do-nothing";
type D = Uncapitalize<"FooBarBaz">
```

::: tip ç”¨inferé€’å½’å¤„ç†
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
// ç¬¬ä¸€æ­¥å†™å‡ºåŸºæœ¬å½¢å¼
type KebabCase<S extends string> = S extends `${infer S1}${infer S2}` ? `${Uncapitalize<S1>}${Uncapitalize<S2>}`:S
// åˆ¤æ–­ S2 å¼€å¤´æ˜¯å¦å¤§å†™ï¼Œå¦‚æœæ˜¯å¤§å†™ï¼Œè½¬æ¢æˆå°å†™ï¼ŒåŒæ—¶åœ¨å‰é¢æ·»åŠ çŸ­æ¨ªçº¿ï¼Œ
// é€’å½’ infer æå–çš„ S2
type KebabCase<S extends string> = S extends `${infer S1}${infer S2}` ? (
  S2 extends `${Uncapitalize<S2>}`?  `${Uncapitalize<S1>}${KebabCase<S2>}`: `${Uncapitalize<S1>}-${KebabCase<S2>}`
):S

```
:::



### å®ç° Diff

è·å–ä¸¤ä¸ªæ¥å£ç±»å‹ä¸­çš„å·®å€¼å±æ€§ã€‚

```ts
type Foo = {
  a: string;
  b: number;
}
type Bar = {
  a: string;
  c: boolean
}

type Result1 = Diff<Foo,Bar> // { b: number, c: boolean }
type Result2 = Diff<Bar,Foo> // { b: number, c: boolean }


```


::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
//
//  è§£æ³•ä¸€ã€æˆ‘è‡ªå·±è§£æ³• å¤ªå¤æ‚äº†ğŸ˜´
// [key in K | J as key extends K & J ? never : key]
// key å±äºå¹¶é›† å•ä¸å±äº äº¤é›†
type Diff<T, U, K extends keyof T = keyof T, J extends keyof U = keyof U> = {
  [key in K | J as key extends K & J ? never : key]:
  key extends K ? key extends J ? never : T[key]
  : (key extends J ? (key extends K ? never : U[key]) : never)
}

// è§£æ³•äºŒ
// [key in keyof (U & T) as key extends keyof (T | U) ? never : key]
// key å±äº T Uçš„å¹¶é›† å•ä¸å±äºäº¤é›†
type Diff<T, U> = {
  [key in keyof (U & T) as key extends keyof (T | U) ? never : key]: (U & T)[key]
}

// è§£æ³•ä¸‰ï¼Œä½¿ç”¨ Omit
// æ³¨æ„äº†è§£ Omit çš„ç”¨æ³•ï¼Œ
type Diff<T, U> = Omit<T & U, keyof (U | T)>



```
:::


**æ‹“å±•**

```ts

// å¦‚æœæ˜¯å¯¹è±¡ç±»å‹ï¼Œ 
//    | è¡¨ç¤º äº¤é›†ï¼Œ& è¡¨ç¤ºå¹¶é›†
// äº¤é›†
type A = keyof (Foo | Bar) // type A = "a" 
// å¹¶é›†
type B = keyof (Foo & Bar) // type B = "a" | "b" | "c"


// å¯¹äºè”åˆç±»å‹ 
//  | è¡¨ç¤º å¹¶é›†ï¼Œ & è¡¨ç¤º äº¤é›†
// å¹¶é›†
type C = (keyof Foo) | (keyof Bar) // type C = "a" | "b" | "c"
// äº¤é›†
type D = (keyof Foo) & (keyof Bar) // type D = "a" 
```







### å®ç° Anyof

 åœ¨ç±»å‹ç³»ç»Ÿä¸­å®ç°ç±»ä¼¼äº Python ä¸­ any å‡½æ•°ã€‚ç±»å‹æ¥æ”¶ä¸€ä¸ªæ•°ç»„ï¼Œå¦‚æœæ•°ç»„ä¸­ä»»ä¸€ä¸ªå…ƒç´ ä¸ºçœŸï¼Œåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œè¿”å› falseã€‚
```ts
type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.

```

::: tip å¯¹è±¡ç±»å‹ ä½¿ç”¨ `keyof` éå† å±æ€§ï¼Œæ•°ç»„ä½¿ç”¨ `[number]` éå†å±æ€§
:::

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ
```ts
type FALSE = 0 | '' | false | [] | { [key: string]: never }


type AnyOf<T extends any[]> = T[number] extends FALSE
  ? false : true;
```
:::


**æ‹“å±•**

```ts
type a1 = {} extends { name: 'a' } ? true : false // false
type b1 = { name: 'a' } extends {} ? true : false // true
type c1 = { [key: string]: never } extends {} ? true : false // true
type d1 = {} extends { [key: string]: never } ? true : false // true
```


### å®ç° IsNever

```ts
type A = IsNever<never>  // expected to be true
type B = IsNever<undefined> // expected to be false
type C = IsNever<null> // expected to be false
type D = IsNever<[]> // expected to be false
type E = IsNever<number> // expected to be false
```

::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsNever<T> = [T] extends [never] ? true : false
```
:::

### [å®ç° isUnion ]


```ts
type case1 = IsUnion<string>  // false
type case2 = IsUnion<string|number>  // true
type case3 = IsUnion<[string|number]>  // false
```


::: danger æœ¬é¢˜æœªè§£ç­”

A extends A å¯¼è‡´Aè¢«åˆ†å‘ï¼Œæ‰€ä»¥åœ¨[B] extends [A] è¿™é‡Œï¼ŒB æ˜¯è”åˆç±»å‹ï¼Œè€ŒA æ˜¯åˆ†å‘ç±»å‹ï¼ŒäºŒè€…å¦‚æœä¸ç­‰ï¼Œé‚£ä¹ˆè¡¨ç¤ºAå°±æ˜¯è”åˆç±»å‹

:::



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts
type IsUnion<A, B = A> = A extends A ? ([B] extends [A] ? false : true) : false;
```
:::





### å®ç°å±æ€§æ›¿æ¢



```ts
type NodeA = {
  type: 'A'
  name: string
  flag: number
}

type NodeB = {
  type: 'B'
  id: number
  flag: number
}

type NodeC = {
  type: 'C'
  name: string
  flag: number
}


type Nodes = NodeA | NodeB | NodeC

// {type: 'A', name: number, flag: string} 
// |{type: 'B', id: number, flag: string} 
// | {type: 'C', name: number, flag: string} 
type ReplacedNodes = ReplaceKeys<Nodes, 'name' | 'flag', { name: number, flag: string }>

// 
// {type: 'A', name: never, flag: number} 
// | NodeB 
// | {type: 'C', name: never, flag: number} // would replace name to never
type ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', { aa: number }> 
```



::: details ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ

```ts

// æˆ‘çš„è§£æ³•
type ReplaceKeys<T, U, S> = T extends T ?
  {
    [key in keyof T]: key extends U ? (
      key extends keyof S ? S[key] : never
    ) : key extends keyof S ? S[key] : T[key]
  }
  : never


// å‚è€ƒç­”æ¡ˆ
type ReplaceKeys<U, T, Y> = U extends U
  ? {
      [I in keyof U]: I extends T ? (I extends keyof Y ? Y[I] : never) : U[I];
    }
  : never;

// å‚è€ƒç­”æ¡ˆ
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? (K extends keyof Y ? Y[K] : never) : U[K]

```

:::





### å®ç°ç§»é™¤ç´¢å¼•ç­¾å

[ä»€ä¹ˆæ˜¯ç´¢å¼•ç­¾åï¼Ÿ](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)

> Only some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.

> ç´¢å¼•ç­¾åå±æ€§åªå…è®¸ä½¿ç”¨æŸäº›ç±»å‹ï¼šå­—ç¬¦ä¸²ã€æ•°å­—ã€ç¬¦å·ã€æ¨¡æ¿å­—ç¬¦ä¸²æ¨¡å¼ä»¥åŠä»…ç”±è¿™äº›ç±»å‹ç»„æˆçš„å¹¶é›†ç±»å‹ã€‚

```ts
type Foo = {
  [key: string]: any;
  foo(): void;
}

type A = RemoveIndexSignature<Foo>  // expected { foo(): void }

```

::: tip `ts`è‡ªå¸¦ç´¢å¼•ç­¾åç±»å‹çš„è”åˆç±»å‹`PropertyKey`
:::


::: details
```ts
type S = string | symbol | number
type RemoveIndexSignature<T, P = S> = {
  [key in keyof T as P extends key ? never : key extends P? key : never]: T[key]
}

```
:::






> TODO â€¦â€¦





## ä¸‰ã€å›°éš¾

### å®ç°æŸ¯é‡ŒåŒ–

// ....







### å®ç° PromiseAll



// ....



> TODO â€¦â€¦







## å››ã€ç›¸å…³é“¾æ¥

[tsè®­ç»ƒè¥](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)
