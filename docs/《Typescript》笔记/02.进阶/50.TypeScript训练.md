---
title: TypeScript训练
date: 2023-05-05 08:56:57
permalink: /pages/a208cd/
categories:
  - 前端
  - 学习笔记
tags:
  - TypeScript
author:
  name: wuxin0011
  link: https://github.com/wuxin0011
---

# typeScript训练

## 一、简单

### 实现 Pick

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
}
```

::: tip

- in
- keyof
- extends

:::

::: details 点击查看答案

```ts
type MyPick<T, K extends keyof T> = {

    [key in K]: T[key]

}
```

:::

### 实现 Readonly



```ts
interface Todo {
    title: string
    description: string
}

const todo: MyReadonly<Todo> = {
    title: "Hey",
    description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```


::: tip 
- in
- keyof
- extends

:::




::: details 点击查看答案

```ts
type MyReadonly<T> = {
    readonly [key in keyof T]: T[key]
}
```

:::

### 实现元组转换对象

传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键/值都是从元组中遍历出来。

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```



::: danger 错误示例

:::

::: details
```ts
type TupleToObject<T extends any[]> = {
    [K in T[number]]: K
}
```
:::


::: tip 正确答案

:::

::: details 点击查看答案

```ts
type TupleToObject<T extends (number | symbol | string)[]> = {
    [K in T[number]]: K
}
```

:::






### 实现提取数组首项

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = First<arr1> // expected to be 'a'
type head2 = First<arr2> // expected to be 3
```

::: details 点击查看答案

```ts
type First<T extends any[]> = T extends [infer F, ...infer] ? F : []
```

:::

### 实现提取数组最后一项

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = End<arr1> // expected to be 'c'
type head2 = End<arr2> // expected to be 1
```

::: details 点击查看答案

```ts
type End<T extends any[]> = T extends [...infer, infer E] ? E : []
```

:::

### 实现 Unshitf

```ts

type Result = Unshift<[1, 2], 0> // [0, 1, 2]

```

::: details 点击查看答案

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

:::

### 实现 Push

```ts

type Result = Push<[1, 2], 0> // [1,2,0]

```

::: details 点击查看答案

```ts
type Push<T extends any[], U> = [...T, U]
```

:::

### 获取元组长度

创建一个通用的`Length`，接受一个`readonly`的数组，返回这个数组的长度。

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

::: tip

- extends
- ts中获取数组获取长度的方式

:::

::: details 点击查看答案

```ts
type Length<T extends readonly any[]> = T['length']
```

:::

### 实现 exclude

::: tip

- never
- extends

:::

::: details 点击查看答案

```ts
type MyExclude<T, U> = U extends T ? never : T
```

:::

### 实现 Include

::: tip

- never
- extends

:::

::: details 点击查看答案

```ts
type MyInclude<T, U> = U extends T ? T : never
```

:::

### 实现 If

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C`
只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

example

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

::: tip

- boolean
- extends

:::

::: details 点击查看答案

```ts
type If<T extends boolean, U, P> = T extends true ? U : P
```

:::

### 实现 concat

::: tip

数组的解构赋值

:::

::: details 点击查看答案

```ts
type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T, ...U];
```

:::

## 二、中等

### 实现获取函数返回类型

不使用 ReturnType 实现 TypeScript 的 `ReturnType<T>` 泛型。
example:

```ts
const fn = (v: boolean) => {
    if (v)
        return 1
    else
        return 2
}

type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
```


::: tip

ts中函数表示方式，可以使用关键词`infer`提取函数返回类型

:::




::: details 点击查看答案

```ts
type MyReturnType<T> = T extends (...args: any) => infer R ? R : never
```

:::




### 实现 Omit

不使用 Omit 实现 TypeScript 的 Omit<T, K> 泛型。

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
    completed: false,
}
```


::: tip

- keyof
- in
- extends
- never

:::




::: details 点击查看答案

```ts
type MyOmit<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P]
}
```

:::


### 实现递归 ReadOnly


```ts
type X = {
    name: 'a',
    age: 12,
    b: {
        c: {
            a: 'role'
        }
    }
}

type Expected = {
    readonly x: {
        readonly a: 1
        readonly b: 'hi'
    }
    readonly y: 'hey'
}

```

::: tip

我个人感觉这种写法不好理解

- keyof
- in
- extends
- never

:::

::: details 点击查看答案

```ts
type DeepReadonly<T> = keyof T extends never ? T : { readonly [k in keyof T]: DeepReadonly<T[k]> };
```

:::



### 实现元组转换成联合类型

```ts
type Arr = ['java', 'javascript', 'typescript', "node", "springboot"]

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'


```



::: tip

- 递归
- infer

:::

::: details 点击查看答案

```ts

// 解法一，自己做的
type TupleToUnion<T extends any[]> = T extends [infer F, ...infer L] ? F | TupleToUnion<L> : never

// 解法二 ，说实话，根本看不懂！
// 原答案链接 https://github.com/type-challenges/type-challenges/issues/284
type TupleToUnion<T extends any[]> = T[number]
```

:::



### 实现可配置可选链

```ts

declare const config: Chainable


const result = config
    .option('foo', 123)
    .option('name', 'type-challenges')
    .option('bar', { value: 'Hello World' })
    .get()

// expect the type of result to be:
type TR = typeof result;
interface Result {
    foo: number
    name: string
    bar: {
        value: string
    }
}


```



::: tip

- 考虑属性是否存在类型中
- 建造者模式（option 方法类似于建造者模式）
- 方法表达式
:::

::: details 点击查看答案

```ts
// 第一步写出最简单形式
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K, v: V) => T,
    get: () => T
};

// 第二部考虑 k 是否存在与 T 中
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T ? never : K, v: V) => T,
    get: () => T
};

// 第三步 如果将 K V 对应属性添加到 T 中 这里使用 Omit<T,K>
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>>,
    get: () => T
};

// 第四步，使用 Record 合并属性
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>&Record<K,V>>,
    get: () => T
};

```


:::


### 实现去掉字符串空格


```ts

type trimed = TrimLeft<'  Hello World  '> // expected to be 'Hello World  
type trimed1 = TrimRright<'  Hello World  '> // expected to be 'Hello World  
type trimed2 = Trim<'  Hello World  '> // expected to be 'Hello World  



```

::: tip 把字符串当数组理解，数组是如何提取，字符串就如何提取
- 递归

- infer

:::




::: details 查看答案

```ts
// 一次性解决吧
type S = ' '
type TrimLeft<T extends string> = T extends `${S}${infer R}` ? TrimLeft<R>:T
type TrimRright<T extends string> = T extends `${infer R}${S}` ? TrimRright<R>:T
type Trim<T extends string> = T extends `${S}${infer R}${S}` ? Trim<R>:T
// 看了答案s = ' '不准确，使用 S = ' ' | '\n' | '\t'
```

::: 





### 实现字符串首字母大写



```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```



::: tip `ts` 中字符串转换成大写 `Uppercase`;小写是 `Lowercase`

:::



::: details 点击查看答案

```ts
type Capitalize<T extends string> = T extends `${infer F}${infer L}` ? `${Uppercase<F>}${L}` : T 

```

:::



拓展

- 实现 全部大写
- 实现 全部小写



### 实现字符串替换

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // expected to be 'types are awesome!'
```



::: tip 使用infer提取，需要考虑空字符串情况

:::

::: details 点击查看答案

```ts
type Replace<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}`?  `${L}${T}${R}`: S
)
```

:::



**拓展**

实现全局替换

```ts
type replaced = ReplaceAll<'fun types fun are fun!', 'fun', 'awesome'> // expected to be 'awesome types awesome are awesome!'
```



::: tip 根据上面使用递归就可以了

:::



::: details 点击查看答案

```ts
type ReplaceAll<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}` ? ReplaceAll<`${L}${T}${R}`, F, T> : S
)
```

:::


### 实现获取字符串长度


::: tip  字符串是是无法直接获取长度，转换成数组，通过递归遍历然后获取
:::

::: details 点击查看答案

```ts
type StrLen<T extends string, Arr extends string[] = []> = T extends `${infer F}${infer R}` ? StrLen<R, [...Arr, F]> : A['length']
```

// eg
type B = StrLen<"javascript"> // 10
:::



### 实现数组扁平化

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]
```
::: tip 递归
:::


::: details 点击查看答案
```ts
type Flatten<T extends any[], O extends any[] = []> =
  T extends [infer F, ...infer R] ? (
    (F extends any[] ? Flatten<[...F, ...R], O> : Flatten<R, [...O, F]>)
  ) : O
```
:::


### 实现参数追加



```ts
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean> 
// expected be (a: number, b: string, x: boolean) => number
```



::: tip 函数表现形式以及参数和返回类型提取

:::





::: details 点击查看答案

```ts

// 第一步写出形式
type AppendArgument<Fn, A> = Fn extends (...args: any[]) => void?(...args: any[]) => void:never

// 第二步使用infer提取参数和返回类型
type AppendArgument<Fn, A> = Fn extends (...args: infer P) => infer T ? (...args: [...P, A]) => T : never
```

:::



### 实现为一个接口添加新类型

实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。

```ts
type Test = { id: '1' }
type Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }
```

::: tip 构造一个K，V给对象，参考Record实现
:::

::: details 点击查看答案
```ts
type AppendToObject<T, U extends keyof any, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```
:::

### 实现连两个对象合并



```ts
type foo = {
  name: string;
  age: string;
}
type coo = {
  age: number;
  sex: string
}

type Result = Merge<foo,coo>; // expected to be {name: string, age: number, sex: string}
```

::: tip  参考上面给对象添加新属性案例，注意后面对象同名属性必须要覆盖前面对象这个要求
:::

::: details 点击查看答案
```ts
type Merge<T, U, K extends keyof T = keyof T, J extends keyof U = keyof U> = {
  [key in J | K]: key extends J ? U[key] : (key extends K ? T[key] : never)
}
```
:::



### 实现 Absolute

实现一个接收string,number或bigInt类型参数的Absolute类型,返回一个正数字符串

```ts
type Test = -100;
type Result = Absolute<Test>; // expected to be "100"
```

::: tip 用字符串和infer处理
:::

::: details 点击查看答案
```ts
type Absolute<T extends string | number | bigint> = `${T}` extends `-${infer R}` ? R : `${T}`
```
:::


### 实现字符串转换联合类型

实现一个接收string,number或bigInt类型参数的Absolute类型,返回一个正数字符串

```ts
type Test = '123';
type Result = StringToUnion<Test>; // expected to be "1" | "2" | "3"
```

::: tip 用infer递归处理
:::

::: details 点击查看答案
```ts
type StringToUnion<T extends string> = T extends `${infer F}${infer R}` ? F | StringToUnion<R> : never
```
:::



### 实现驼峰命名转换短横线命名


```ts
type FooBarBaz = KebabCase<"FooBarBaz">;
const foobarbaz: FooBarBaz = "foo-bar-baz";

type DoNothing = KebabCase<"do-nothing">;
const doNothing: DoNothing = "do-nothing";
type D = Uncapitalize<"FooBarBaz">
```

::: tip 用infer递归处理
:::

::: details 点击查看答案
```ts
// 第一步写出基本形式
type KebabCase<S extends string> = S extends `${infer S1}${infer S2}` ? `${Uncapitalize<S1>}${Uncapitalize<S2>}`:S
// 判断 S2 开头是否大写，如果是大写，转换成小写，同时在前面添加短横线，
// 递归 infer 提取的 S2
type KebabCase<S extends string> = S extends `${infer S1}${infer S2}` ? (
  S2 extends `${Uncapitalize<S2>}`?  `${Uncapitalize<S1>}${KebabCase<S2>}`: `${Uncapitalize<S1>}-${KebabCase<S2>}`
):S

```
:::



### 实现 Diff

获取两个接口类型中的差值属性。

```ts
type Foo = {
  a: string;
  b: number;
}
type Bar = {
  a: string;
  c: boolean
}

type Result1 = Diff<Foo,Bar> // { b: number, c: boolean }
type Result2 = Diff<Bar,Foo> // { b: number, c: boolean }


```


::: details 点击查看答案
```ts
//
//  解法一、我自己解法 太复杂了😴
// [key in K | J as key extends K & J ? never : key]
// key 属于并集 单不属于 交集
type Diff<T, U, K extends keyof T = keyof T, J extends keyof U = keyof U> = {
  [key in K | J as key extends K & J ? never : key]:
  key extends K ? key extends J ? never : T[key]
  : (key extends J ? (key extends K ? never : U[key]) : never)
}

// 解法二
// [key in keyof (U & T) as key extends keyof (T | U) ? never : key]
// key 属于 T U的并集 单不属于交集
type Diff<T, U> = {
  [key in keyof (U & T) as key extends keyof (T | U) ? never : key]: (U & T)[key]
}

// 解法三，使用 Omit
// 注意了解 Omit 的用法，
type Diff<T, U> = Omit<T & U, keyof (U | T)>



```
:::


**拓展**

```ts

// 如果是对象类型， 
//    | 表示 交集，& 表示并集
// 交集
type A = keyof (Foo | Bar) // type A = "a" 
// 并集
type B = keyof (Foo & Bar) // type B = "a" | "b" | "c"


// 对于联合类型 
//  | 表示 并集， & 表示 交集
// 并集
type C = (keyof Foo) | (keyof Bar) // type C = "a" | "b" | "c"
// 交集
type D = (keyof Foo) & (keyof Bar) // type D = "a" 
```







### 实现 Anyof

 在类型系统中实现类似于 Python 中 any 函数。类型接收一个数组，如果数组中任一个元素为真，则返回 true，否则返回 false。如果数组为空，返回 false。
```ts
type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.

```

::: tip 对象类型 使用 `keyof` 遍历 属性，数组使用 `[number]` 遍历属性
:::

::: details 点击查看答案
```ts
type FALSE = 0 | '' | false | [] | { [key: string]: never }


type AnyOf<T extends any[]> = T[number] extends FALSE
  ? false : true;
```
:::


**拓展**

```ts
type a1 = {} extends { name: 'a' } ? true : false // false
type b1 = { name: 'a' } extends {} ? true : false // true
type c1 = { [key: string]: never } extends {} ? true : false // true
type d1 = {} extends { [key: string]: never } ? true : false // true
```


### 实现 IsNever

```ts
type A = IsNever<never>  // expected to be true
type B = IsNever<undefined> // expected to be false
type C = IsNever<null> // expected to be false
type D = IsNever<[]> // expected to be false
type E = IsNever<number> // expected to be false
```

::: details 点击查看答案

```ts
type IsNever<T> = [T] extends [never] ? true : false
```
:::

### [实现 isUnion ]


```ts
type case1 = IsUnion<string>  // false
type case2 = IsUnion<string|number>  // true
type case3 = IsUnion<[string|number]>  // false
```


::: danger 本题未解答

A extends A 导致A被分发，所以在[B] extends [A] 这里，B 是联合类型，而A 是分发类型，二者如果不等，那么表示A就是联合类型

:::



::: details 点击查看答案

```ts
type IsUnion<A, B = A> = A extends A ? ([B] extends [A] ? false : true) : false;
```
:::





### 实现属性替换



```ts
type NodeA = {
  type: 'A'
  name: string
  flag: number
}

type NodeB = {
  type: 'B'
  id: number
  flag: number
}

type NodeC = {
  type: 'C'
  name: string
  flag: number
}


type Nodes = NodeA | NodeB | NodeC

// {type: 'A', name: number, flag: string} 
// |{type: 'B', id: number, flag: string} 
// | {type: 'C', name: number, flag: string} 
type ReplacedNodes = ReplaceKeys<Nodes, 'name' | 'flag', { name: number, flag: string }>

// 
// {type: 'A', name: never, flag: number} 
// | NodeB 
// | {type: 'C', name: never, flag: number} // would replace name to never
type ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', { aa: number }> 
```



::: details 点击查看答案

```ts

// 我的解法
type ReplaceKeys<T, U, S> = T extends T ?
  {
    [key in keyof T]: key extends U ? (
      key extends keyof S ? S[key] : never
    ) : key extends keyof S ? S[key] : T[key]
  }
  : never


// 参考答案
type ReplaceKeys<U, T, Y> = U extends U
  ? {
      [I in keyof U]: I extends T ? (I extends keyof Y ? Y[I] : never) : U[I];
    }
  : never;

// 参考答案
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? (K extends keyof Y ? Y[K] : never) : U[K]

```

:::





### 实现移除索引签名

[什么是索引签名？](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)

> Only some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.

> 索引签名属性只允许使用某些类型：字符串、数字、符号、模板字符串模式以及仅由这些类型组成的并集类型。

```ts
type Foo = {
  [key: string]: any;
  foo(): void;
}

type A = RemoveIndexSignature<Foo>  // expected { foo(): void }

```

::: tip `ts`自带索引签名类型的联合类型`PropertyKey`
:::


::: details
```ts
type S = string | symbol | number
type RemoveIndexSignature<T, P = S> = {
  [key in keyof T as P extends key ? never : key extends P? key : never]: T[key]
}

```
:::






> TODO ……





## 三、困难

### 实现柯里化

// ....







### 实现 PromiseAll



// ....



> TODO ……







## 四、相关链接

[ts训练营](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)
