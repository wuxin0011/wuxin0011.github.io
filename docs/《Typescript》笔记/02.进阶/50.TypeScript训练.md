---
title: TypeScript训练
date: 2023-05-05 08:56:57
permalink: /pages/a208cd/
categories:
  - 前端
  - 学习笔记
tags:
  - TypeScript
author:
  name: wuxin0011
  link: https://github.com/wuxin0011
---

# typeScript训练

## 一、简单

### 实现Pick

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
}
```

::: tip

- in
- keyof
- extends

:::

::: details 点击查看答案

```ts
type MyPick<T, K extends keyof T> = {

    [key in K]: T[key]

}
```

:::

### 实现Readonly



```ts
interface Todo {
    title: string
    description: string
}

const todo: MyReadonly<Todo> = {
    title: "Hey",
    description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```


::: tip 
- in
- keyof
- extends

:::




::: details 点击查看答案

```ts
type MyReadonly<T> = {
    readonly [key in keyof T]: T[key]
}
```

:::

### 实现元组转换对象

传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键/值都是从元组中遍历出来。

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```



::: danger 错误示例

:::

::: details
```ts
type TupleToObject<T extends any[]> = {
    [K in T[number]]: K
}
```
:::


::: tip 正确答案

:::

::: details 点击查看答案

```ts
type TupleToObject<T extends (number | symbol | string)[]> = {
    [K in T[number]]: K
}
```

:::

### 实现提取数组首项

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = First<arr1> // expected to be 'a'
type head2 = First<arr2> // expected to be 3
```

::: details 点击查看答案

```ts
type First<T extends any[]> = T extends [infer F, ...infer] ? F : []
```

:::

### 实现提取数组最后一项

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

// 
type head1 = End<arr1> // expected to be 'c'
type head2 = End<arr2> // expected to be 1
```

::: details 点击查看答案

```ts
type End<T extends any[]> = T extends [...infer, infer E] ? E : []
```

:::

### 实现Unshitf

```ts

type Result = Unshift<[1, 2], 0> // [0, 1, 2]

```

::: details 点击查看答案

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

:::

### 实现Push

```ts

type Result = Push<[1, 2], 0> // [1,2,0]

```

::: details 点击查看答案

```ts
type Push<T extends any[], U> = [...T, U]
```

:::

### 获取元组长度

创建一个通用的`Length`，接受一个`readonly`的数组，返回这个数组的长度。

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

::: tip

- extends
- ts中获取数组获取长度的方式

:::

::: details 点击查看答案

```ts
type Length<T extends readonly any[]> = T['length']
```

:::

### 实现exclude

::: tip

- never
- extends

:::

::: details 点击查看答案

```ts
type MyExclude<T, U> = U extends T ? never : T
```

:::

### 实现 Include

::: tip

- never
- extends

:::

::: details 点击查看答案

```ts
type MyInclude<T, U> = U extends T ? T : never
```

:::

### 实现If

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C`
只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

example

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

::: tip

- boolean
- extends

:::

::: details 点击查看答案

```ts
type If<T extends boolean, U, P> = T extends true ? U : P
```

:::

### 实现concat

::: tip

数组的解构赋值

:::

::: details 点击查看答案

```ts
type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T, ...U];
```

:::

## 二、中等

### 实现获取函数返回类型

不使用 ReturnType 实现 TypeScript 的 `ReturnType<T>` 泛型。
example:

```ts
const fn = (v: boolean) => {
    if (v)
        return 1
    else
        return 2
}

type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
```


::: tip

ts中函数表示方式，可以使用关键词`infer`提取函数返回类型

:::




::: details 点击查看答案

```ts
type MyReturnType<T> = T extends (...args: any) => infer R ? R : never
```

:::




### 实现 omit

不使用 Omit 实现 TypeScript 的 Omit<T, K> 泛型。

Omit 会创建一个省略 K 中字段的 T 对象。

```ts
interface Todo {
    title: string
    description: string
    completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
    completed: false,
}
```


::: tip

- keyof
- in
- extends
- never
- 判断对象是否存在与对象中，如果不存在，就添加属性

:::




::: details 点击查看答案

```ts
type MyOmit<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P]
}
```

:::


### 实现递归ReadOnly


```ts
type X = {
    name: 'a',
    age: 12,
    b: {
        c: {
            a: 'role'
        }
    }
}

type Expected = {
    readonly x: {
        readonly a: 1
        readonly b: 'hi'
    }
    readonly y: 'hey'
}

```

::: tip

我个人感觉这种写法不好理解

- keyof
- in
- extends
- never
- 判断对象是否存在与对象中，如果不存在，就添加属性

:::

::: details 点击查看答案

```ts
type DeepReadonly<T> = keyof T extends never ? T : { readonly [k in keyof T]: DeepReadonly<T[k]> };
```

:::



### 实现元组转换成联合类型

```ts
type Arr = ['java', 'javascript', 'typescript', "node", "springboot"]

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'


```



::: tip

- 递归
- infer

:::

::: details 点击查看答案

```ts

// 解法一，自己做的
type TupleToUnion<T extends any[]> = T extends [infer F, ...infer L] ? F | TupleToUnion<L> : never

// 解法二 ，说实话，根本看不懂！
// 原答案链接 https://github.com/type-challenges/type-challenges/issues/284
type TupleToUnion<T extends any[]> = T[number]
```

:::



### 实现可配置可选链

```ts

declare const config: Chainable


const result = config
    .option('foo', 123)
    .option('name', 'type-challenges')
    .option('bar', { value: 'Hello World' })
    .get()

// expect the type of result to be:
type TR = typeof result;
interface Result {
    foo: number
    name: string
    bar: {
        value: string
    }
}


```



::: tip

- 考虑属性是否存在类型中
- 建造者模式（option 方法类似于建造者模式）
- 方法表达式
:::

::: details 点击查看答案

```ts
// 第一步写出最简单形式
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K, v: V) => T,
    get: () => T
};

// 第二部考虑 k 是否存在与 T 中
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T ? never : K, v: V) => T,
    get: () => T
};

// 第三步 如果将 K V 对应属性添加到 T 中 这里使用 Omit<T,K>
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>>,
    get: () => T
};

// 第四步，使用 Record 合并属性
type Chainable<T = {}> = {
    option: <K extends string, V>(k: K extends keyof T? never : K, v: V) => Chainable<Omit<T,K>&Record<K,V>>,
    get: () => T
};

```


:::


### 实现去掉字符串空格


```ts

type trimed = TrimLeft<'  Hello World  '> // expected to be 'Hello World  
type trimed1 = TrimRright<'  Hello World  '> // expected to be 'Hello World  
type trimed2 = Trim<'  Hello World  '> // expected to be 'Hello World  



```

::: tip 把字符串当数组理解，数组是如何提取，字符串就如何提取
- 递归

- infer

:::




::: details 查看答案

```ts
// 一次性解决吧
type S = ' '
type TrimLeft<T extends string> = T extends `${S}${infer R}` ? TrimLeft<R>:T
type TrimRright<T extends string> = T extends `${infer R}${S}` ? TrimRright<R>:T
type Trim<T extends string> = T extends `${S}${infer R}${S}` ? Trim<R>:T
// 看了答案s = ' '不准确，使用 S = ' ' | '\n' | '\t'
```

::: 





### 实现字符串首字母大写



```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```



::: tip `ts` 中字符串转换成大写 `Uppercase`;小写是 `Lowercase`

:::



::: details 点击查看答案

```ts
type Capitalize<T extends string> = T extends `${infer F}${infer L}` ? `${Uppercase<F>}${L}` : T 

```

:::



拓展

- 实现 全部大写
- 实现 全部小写



### 实现字符串替换

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // expected to be 'types are awesome!'
```



::: tip 使用infer提取，需要考虑空字符串情况

:::

::: details 点击查看答案

```ts
type Replace<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}`?  `${L}${T}${R}`: S
)
```

:::



**拓展**

实现全局替换

```ts
type replaced = ReplaceAll<'fun types fun are fun!', 'fun', 'awesome'> // expected to be 'awesome types awesome are awesome!'
```



::: tip 根据上面使用递归就可以了

:::



::: details 点击查看答案

```ts
type ReplaceAll<S extends string, F extends string, T extends string> = S extends '' ? S : (
    S extends `${infer L}${F}${infer R}` ? ReplaceAll<`${L}${T}${R}`, F, T> : S
)
```

:::



### 实现参数追加



```ts
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean> 
// expected be (a: number, b: string, x: boolean) => number
```



::: tip 函数表现形式以及参数和返回类型提取

:::





::: details 点击查看答案

```ts

// 第一步写出形式
type AppendArgument<Fn, A> = Fn extends (...args: any[]) => void?(...args: any[]) => void:never

// 第二步使用infer提取参数和返回类型
type AppendArgument<Fn, A> = Fn extends (...args: infer P) => infer T ? (...args: [...P, A]) => T : never
```

:::










> TODO ……





## 三、困难

### 实现柯里化

// ....







### 实现 PromiseAll



// ....



> TODO ……







## 四、相关链接

[ts训练营](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)
